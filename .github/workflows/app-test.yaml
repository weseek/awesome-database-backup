name: Application - Test

on:
  push:
    branches-ignore: [stable]
    paths-ignore:
    - ".**"
    - "!.devcontainer"
    - "!.github/workflows/app-test.yaml"
    - "docker/**"
    - "**.md"

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    # Increase workspace space
    - name: Remove docker image
      run: |
        docker image prune --force --all
    - uses: actions/checkout@v4
    # Pull the latest image to build, and avoid caching pull-only images.
    # (docker pull is faster than caching in most cases.)
    - name: Pull Docker images
      run: docker-compose -f .devcontainer/docker-compose.yml pull
    # In this step, this action saves a list of existing images,
    # the cache is created without them in the post run.
    # It also restores the cache if it exists.
    - name: Load cached Docker layers
      uses: satackey/action-docker-layer-caching@v0.0.11
      # Ignore the failure of a step and avoid terminating the job.
      continue-on-error: true
    # This step loads "node_modules" from the cache which contains the cache of Turborepo.
    # The "node_modules" will be mounted with the source code when docker-compose up is executed.
    - name: Load cache "node_modules" which includes cahce of Turborepo
      uses: actions/cache@v4
      env:
        cache-name: cache-node-modules
      with:
        path: node_modules
        key:
          ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-build-${{ env.cache-name }}-
    - name: Start all DBs and middle
      run: |
        docker-compose -f .devcontainer/docker-compose.yml build --build-arg USER_UID=$(id -u) --build-arg USER_GID=$(id -g)
        docker-compose -f .devcontainer/docker-compose.yml up -d
    - name: Run test
      run:
        docker-compose -f .devcontainer/docker-compose.yml exec -T -- node bash -c 'yarn install && yarn test'
    # [TODO] Coverage report
